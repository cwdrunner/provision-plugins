#!/usr/bin/env bash
# Configure the IPMI subsystem

. helper

{{ if eq (.Param "rs-debug-enable") true -}}
set -x
{{end -}}

fail() {
    echo "Failed"
    exit 1
}

success() {
    echo "Success"
    exit 0
}

HP_SYSTEM=false
DELL_SYSTEM=false
mfgr=$(drpcli gohai |jq -r '.DMI | .System | .Manufacturer')
if [[ $mfgr == HP ]] ; then
  HP_SYSTEM=true
fi
if [[ $mfgr == HPE ]] ; then
  HP_SYSTEM=true
fi
if [[ $mfgr == "Dell Inc." ]] ; then
  DELL_SYSTEM=true
fi

# Who am I
export RS_UUID={{.Machine.Uuid}}
export RS_TOKEN={{.GenerateToken}}
export RS_ENDPOINT={{.ApiURL}}

# Set some sane defaults
IPMI_CONFIGURE_ADDRESS=""
IPMI_CONFIGURE_NETMASK=""
IPMI_CONFIGURE_GATEWAY=""
IPMI_CONFIGURE_PORT=""

IPMI_CONFIGURE_USERID=""

# Gather Variables for configuration
IPMI_SERVICE_USER={{.Param "ipmi/service-user"}}
IPMI_CONFIGURE_FAIL={{.Param "ipmi/configure/no-bmc-fatal"}}
IPMI_CONFIGURE_NETWORK={{.Param "ipmi/configure/network"}}
IPMI_CONFIGURE_RESERVE_IP={{.Param "ipmi/configure/reserve-ip"}}
IPMI_CONFIGURE_IP_MODE={{.Param "ipmi/configure/ip-mode"}}
{{if .ParamExists "ipmi/configure/address"}}
IPMI_CONFIGURE_ADDRESS={{.Param "ipmi/configure/address"}}
{{end}}
{{if .ParamExists "ipmi/configure/netmask"}}
IPMI_CONFIGURE_NETMASK={{.Param "ipmi/configure/netmask"}}
{{end}}
{{if .ParamExists "ipmi/configure/gateway"}}
IPMI_CONFIGURE_GATEWAY={{.Param "ipmi/configure/gateway"}}
{{end}}
{{if .ParamExists "ipmi/configure/port"}}
IPMI_CONFIGURE_PORT={{.Param "ipmi/configure/port"}}
{{end}}

IPMI_CONFIGURE_USER={{.Param "ipmi/configure/user"}}
IPMI_CONFIGURE_USERNAME={{.Param "ipmi/configure/username"}}
IPMI_CONFIGURE_PASSWORD={{.Param "ipmi/configure/password"}}
{{if .ParamExists "ipmi/configure/userid"}}
IPMI_CONFIGURE_USERID={{.Param "ipmi/configure/userid"}}
{{end}}

# Results variables
IPMI_ENABLED=false
IPMI_ADDRESS=""

{{if .ParamExists "ipmi/address"}}
IPMI_ADDRESS={{.Param "ipmi/address"}}
{{end}}
{{if .ParamExists "ipmi/username"}}
IPMI_USERNAME={{.Param "ipmi/username"}}
{{end}}
{{if .ParamExists "ipmi/password"}}
IPMI_PASSWORD={{.Param "ipmi/password"}}
{{end}}

IPMI_FORCE_LAN_CHAN=0
IPMI_LAN_CHECK_START=1
IPMI_LAN_CHECK_END=11
{{if .ParamExists "ipmi/force-lan-chan"}}
IPMI_FORCE_LAN_CHAN={{.Param "ipmi/force-lan-chan"}}
IPMI_LAN_CHECK_START=$IPMI_FORCE_LAN_CHAN
IPMI_LAN_CHECK_END=$IPMI_FORCE_LAN_CHAN
{{end}}

declare -A quirk_data
declare -A mc_info
declare -A lan_info
declare -A mc_info_keys
declare -A lan_info_keys
lan_chan=0

quirklist=()
quirkid="UNKNOWN"

mc_info_keys=(
    ["Device ID"]="device_id"
    ["Device Revision"]="device_rev"
    ["Firmware Revision"]="firmware_rev"
    ["IPMI Version"]="version"
    ["Manufacturer ID"]="mfgr_id"
    ["Manufacturer Name"]="mfgr_name"
    ["Product ID"]="product_id"
    ["Product Name"]="product_name"
    ["Device Available"]="available"
    ["Provides Device SDRs"]="provides_device_sdrs"
    ["Additional Device Support"]="additional_devs"
)

lan_info_keys=(
    ["IP Address"]="ipaddr"
    ["Subnet Mask"]="netmask"
    ["Default Gateway IP"]="defgw ipaddr"
    ["MAC Address"]="macaddr"
    ["IP Address Source"]="ipsrc"
)

#
# This routine will mark the parameters to skip IPMI on
# systems that don't have IPMI subsystems or fail.
#
disable_ipmi() {
    echo "IPMI Subsystem not available on this node."

    # Mark address as empty to make sure that actions aren't available.
    drpcli machines set $RS_UUID param ipmi/enabled to false
    if ! drpcli machines remove $RS_UUID param ipmi/address; then
        true
    fi

    if [[ $IPMI_CONFIGURE_FAIL == true ]] ; then
        fail
    else
        success
    fi
}


load_ipmi() {
    echo "Loading IPMI modules"
    [[ -d /sys/module/ipmi_devintf ]] || modprobe ipmi_devintf &>/dev/null || :
    [[ -d /sys/module/ipmi_si ]] || modprobe ipmi_si &>/dev/null || :
    [[ -d /sys/module/ipmi_ssif ]] || modprobe ipmi_ssif &>/dev/null || :
    if ! [[ -d /sys/module/ipmi_si ||
            -d /sys/module/ipmi_devintf ||
            -d /sys/module/ipmi_ssif ]]; then
        echo "Failed to load ipmi kernel modules"
        disable_ipmi
        return
    fi
    [[ -e /dev/ipmi0 || -e /dev/ipmi/0 || -e /dev/ipmidev/0 ]] && return || :
    echo "No IPMI devices present"
    IPMI_CONFIGURE_FAIL=false
    disable_ipmi
}

trim() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

tool() {
    if [[ $ipmi_nodelay == "" ]] ; then
        sleep 5
    fi
    if ! [[  "$@" =~ password ]] ; then
        echo "ipmitool $@"
    else
        echo "ipmitool password setting command"
    fi >&2
    ipmitool "$@"
}

process_quirks() {
    OLD_IFS=$IFS
    IFS=""
    array=false
    index=0
    level=()
    tq=()
    score=0
    maxscore=0
    testvalue=""
    while read line
    do
            if [[ $line =~ ^# ]] ; then
                    continue
            fi

            front=${line%%:*}
            back=$(trim ${line#*:})

            oldarray=$array
            if [[ $front == $line ]] ; then
                front=${line%%-*}
                back=$(trim ${line#*-})
                array=true
                tq=()
            else
                array=false
            fi
            if [[ $oldarray != $array && $array == true ]] ; then
                index=0
            fi

            spaces="${front//[^ ]}"
            count=$((${#spaces} / 2))

            tf=$(trim $front)
            if [[ $back == "" ]] ; then
                    if [[ $count == 0 ]] ; then
                         if [[ $testvalue != "" ]] ; then
                                 if [[ ${mc_info[$testkey]} == $testvalue ]] ; then
                                     score=$(($score + $testscore))
                                 fi
                                 if [[ \"${mc_info[$testkey]}\" == $testvalue ]] ; then
                                     score=$(($score + $testscore))
                                 fi
                         fi
                         testvalue=""
                         if (( $maxscore < $score )) ; then
                             quirkid=${level[0]}
                             maxscore=$score
                             quirklist=$tq
                         fi
                         score=0
                    fi
                    if [[ $count == 3 ]] ; then
                         if [[ $testvalue != "" ]] ; then
                                 if [[ ${mc_info[$testkey]} == $testvalue ]] ; then
                                     score=$(($score + $testscore))
                                 fi
                                 if [[ \"${mc_info[$testkey]}\" == $testvalue ]] ; then
                                     score=$(($score + $testscore))
                                 fi
                         fi
                         testkey=$tf
                         testscore=1
                    fi
                    level[$count]=$tf
            else
                    if [[ $array == true ]] ; then
                        tq[$index]=$back
                    else
                        if [[ $count == 4 && $tf == "match" ]] ; then
                            testvalue=$back
                        fi
                        if [[ $count == 4 && $tf == "score" ]] ; then
                            testscore=$back
                        fi
                    fi
            fi

    done < "ipmi-quirks.yaml"
    if [[ $testvalue != "" ]] ; then
            if [[ ${mc_info[$testkey]} == $testvalue ]] ; then
                score=$(($score + $testscore))
            fi
            if [[ \"${mc_info[$testkey]}\" == $testvalue ]] ; then
                score=$(($score + $testscore))
            fi
    fi
    testvalue=""
    if (( $maxscore < $score )) ; then
        maxscore=$score
        quirkid=${level[0]}
        quirklist=$tq
    fi
    IFS=$OLD_IFS
}

mc_info() {
    echo "Gathering MC info"
    count=0
    while (($count < 5)) ; do
        while read line
        do
            tkey=$(trim ${line%%:*})
            key=${mc_info_keys["$tkey"]}
            value=$(trim ${line#*:})

            if [[ $key == "" ]] ; then
                continue
            fi
            if [[ $value == "" ]] ; then
                continue
            fi

            mc_info["$key"]="$value"
        done < <(tool mc info)

        if [[ ${mc_info["version"]} != "" ]] ; then
            break
        fi

        echo "attempt $count failed -  trying again..."
        count=$(($count + 1))
        sleep 1
    done

    if (($count == 5)) ; then
        echo "Failed to get base board controller info"
        disable_ipmi
    fi
}

lan_info() {
    echo "Gathering Lan Info"
    for ((i=$IPMI_LAN_CHECK_START;i<=$IPMI_LAN_CHECK_END;i++)); do
        lan_chan=$i
        while read line
        do
            tkey=$(trim ${line%%:*})
            if [[ $tkey == "" ]] ; then
                continue
            fi

            key=${lan_info_keys["$tkey"]}
            value=$(trim ${line#*:})

            if [[ $key == "" ]] ; then
                continue
            fi
            if [[ $value == "" ]] ; then
                continue
            fi

            lan_info["$key"]="$value"
        done < <(tool lan print $lan_chan)

        if [[ $IPMI_FORCE_LAN_CHAN == $lan_chan ]] ; then
            break
        fi
        if [[ ${lan_info["ipsrc"]} != "" ]] ; then
            break
        fi
    done
}


# Load the ipmi layer
load_ipmi

# Get MC info
mc_info

# Get Lan Info
lan_info

# Identify MC and get quirks
process_quirks

echo "System has been identified as: $quirkid"
echo "Using these quirks: ${quirklist[@]}"

# Set the quirks as vars
for q in "${quirklist[@]}"
do
        key=${q//-/_}
        export ${key}=true
done

id_for_user() {
    tool user list $lan_chan |awk "\$2 == \"$1\" { print \$1 }"
}

declare -A ipmi_user

parse_ipmitool_user_line() {
    local line id user callin link msg priv
    line="$*"
    ipmi_user["id"]=$(trim ${line:0:4})
    case $(trim ${line:4:17}) in
        ''|'(Empty User)') ipmi_user["user"]='';;
        *) ipmi_user["user"]="$(trim ${line:4:17})";;
    esac
    case $(trim ${line:21:8}) in
        "true"|"on") ipmi_user["callin"]="on";;
        *) ipmi_user["callin"]="off";;
    esac
    case $(trim ${line:21:8}) in
        "true"|"on") ipmi_user["link"]="on";;
        *) ipmi_user["link"]="off";;
    esac
    case $(trim ${line:40:11}) in
        "true"|"on") ipmi_user["msg"]="on";;
        *) ipmi_user["link"]="off";;
    esac
    case $(trim ${line:51}) in
        "NO ACCESS") ipmi_user["priv"]="15";;
        "OEM"*) ipmi_user["priv"]="5";;
        "ADMINISTRATOR") ipmi_user["priv"]="4";;
        "OPERATOR") ipmi_user["priv"]="3";;
        "USER") ipmi_user["priv"]="2";;
        "CALLBACK") ipmi_user["priv"]="1";;
    esac
}

first_free_id() {
    local line id user
    while read line; do
        parse_ipmitool_user_line "$line"
        ## All sorts of things rely on user 1 being left alone.
        [[ ${ipmi_user["id"]} = 1 ]] && continue
        ## immutable root == go on toi the next ID.
        [[ ${ipmi_user["id"]} = 2 && ($ipmi_immutable_rootname == true || $ipmi_immutable_root == true) ]] && continue
        # If there is a named user here, continue
        [[ ${ipmi_user["user"]} ]] && continue
        echo ${ipmi_user["id"]}
        return
    done < <(tool user list $lan_chan)
    [[ $ipmi_immutable_rootname == true || $ipmi_immutable_root == true ]] && echo 3 || echo 2
}

configure_user() {
    # $1 = username
    # $2 = password
    # $3 = userid (optional)
    local existing_id configure_id starting_id
    existing_id=$(id_for_user "$1")
    configure_id="$3"
    if [[ $configure_id && $existing_id && $configure_id != $existing_id ]]; then
        echo "Requested username is already on the system.  Using that ID instead of requested one"
        configure_id="$existing_id"
    elif [[ $existing_id ]]; then
        configure_id="$existing_id"
    fi
    [[ $configure_id ]] || configure_id=$(first_free_id)
    if [[ $configure_id = 2 && $ipmi_immutable_root == true ]]; then
        echo "WARNING: Trying to modify the base account on a system with immutable ROOT"
        echo "This may not work!!"
    fi
    [[ $existing_id ]] || tool user set name $configure_id "$1"
    tool user set password $configure_id "$2"
    tool user priv $configure_id 4 $lan_chan
    [[ $ipmi_crossed_access_channels = true ]] || \
        tool channel setaccess $lan_chan $configure_id callin=on link=on ipmi=on privilege=4
    tool user enable $configure_id
    if [[ $HP_SYSTEM == true ]] ; then
        if [[ -x /usr/sbin/hponcfg ]]; then
            fgrep '<IPMI_DCMI_OVER_LAN_ENABLED VALUE="Y"/>' < <(hponcfg -i <<EOI
<RIBCL VERSION="2.0">
 <LOGIN USER_LOGIN="$1" PASSWORD="$2">
  <RIB_INFO MODE="read">
   <GET_GLOBAL_SETTINGS />
  </RIB_INFO>
 </LOGIN>
</RIBCL>
EOI
) || hponcfg -i <<EOI
<RIBCL VERSION="2.0">
 <LOGIN USER_LOGIN="$1" PASSWORD="$2">
  <RIB_INFO MODE="write">
   <MOD_GLOBAL_SETTINGS>
    <IPMI_DCMI_OVER_LAN_ENABLED VALUE="Yes"/>
   </MOD_GLOBAL_SETTINGS>
  </RIB_INFO>
 </LOGIN>
</RIBCL>
EOI
        else
            echo "HP system detected, but no hponcfg binary present."
            echo "Please rework your ipmi configure workload to make sure the"
            echo "hardware-tools-install stage is before the ipmi-configure stage."
            echo
            echo "This task cannot guarantee that remote access is enabled on this system without it."
        fi
    else
        if [[ $ipmi_crossed_access_channels != true ]] ; then
            tool lan set $lan_chan access on
        fi
    fi
    configured=true
}


random_password() {
    (< /dev/urandom tr -dc '[:alnum:]' | head -c10) || :
}

configured=false

ipmi_user_configured() {
    drpcli machines runaction "$RS_UUID" powerstatus ipmi/username "$1" ipmi/password "$2" &>/dev/null || false
}

# Do the config actions - configure user
if [[ $IPMI_CONFIGURE_USER == true ]] && ! ipmi_user_configured "$IPMI_CONFIGURE_USERNAME" "$IPMI_CONFIGURE_PASSWORD"; then
    echo "Configure USER account $IPMI_CONFIGURE_USERNAME"
    configure_user "$IPMI_CONFIGURE_USERNAME" "$IPMI_CONFIGURE_PASSWORD" $IPMI_CONFIGURE_USERID
    if [[ $IPMI_SERVICE_USER != true ]]; then
        drpcli machines set $RS_UUID param ipmi/username to "$IPMI_CONFIGURE_USERNAME"
        drpcli machines set $RS_UUID param ipmi/password to "$IPMI_CONFIGURE_PASSWORD"
    fi
fi

if [[ $IPMI_SERVICE_USER = true ]] && ! ipmi_user_configured dr-provision "$IPMI_PASSWORD"; then
    echo "Creating service account for dr-provision"
    auto_password="dR$(random_password)0!"
    configure_user dr-provision "$auto_password"
    drpcli machines set $RS_UUID param ipmi/username to dr-provision
    drpcli machines set $RS_UUID param ipmi/password to "$auto_password"
fi

# Do the config actions - configure network
if [[ $IPMI_CONFIGURE_NETWORK == true ]] ; then
    echo "Configure Network"

    # First is this a dell system.  If so, set shared or dedicated.
    if [[ $ipmi_dell_dedicated_nic == true && $IPMI_CONFIGURE_PORT != "" ]] ; then
        if [[ $(tool delloem lan get) != $IPMI_CONFIGURE_PORT ]]; then
            echo "Setting DELL iDrac port to $IPMI_CONFIGURE_PORT mode"
            tool delloem lan set $IPMI_CONFIGURE_PORT
            configured=true
        fi
    fi

    if [[ $IPMI_CONFIGURE_RESERVE_IP == true && $IPMI_CONFIGURE_ADDRESS != "" ]] ; then
        # Need to reserve an IP.
        MACADDR=${lan_info["macaddr"]}
        if [[ $(drpcli reservations show $IPMI_CONFIGURE_ADDRESS |jq -r '.Token' ) != $MACADDR ]]; then
            data="{ \"Strategy\": \"MAC\", \"Addr\": \"$IPMI_CONFIGURE_ADDRESS\", \"Token\": \"$MACADDR\" }"
            drpcli reservations create "$data"

            echo "Reserving (specified) $IPMI_CONFIGURE_ADDRESS for ${lan_info["macaddr"]}"
        fi
    elif [[ $IPMI_CONFIGURE_RESERVE_IP == true && $IPMI_CONFIGURE_IP_MODE == "static" ]] ; then

        echo "This mode is not currently supported!!!"
        IPMI_CONFIGURE_FAIL=true
        disable_ipmi

        # We are told to pick an address from something some how.
        IPMI_CONFIGURE_ADDRESS="FILL IN SOMETHING HERE ONE DAY"
        MACADDR=${lan_info["macaddr"]}
        data="{ \"Strategy\": \"MAC\", \"Addr\": \"$IPMI_CONFIGURE_ADDRESS\", \"Token\": \"$MACADDR\" }"
        drpcli reservations create "$data"
        echo "Reserving (static) $IPMI_CONFIGURE_ADDRESS for ${lan_info["macaddr"]}"
    fi


    if [[ $IPMI_CONFIGURE_IP_MODE == dhcp ]] ; then
        if [[ ${lan_info["ipsrc"]} != "DHCP Address" ]] ; then
            tool lan set $lan_chan ipsrc dhcp
            configured=true
        fi
    elif [[ $IPMI_CONFIGURE_IP_MODE == "static" ]] ; then
        if [[ $IPMI_CONFIGURE_ADDRESS == "" || $IPMI_CONFIGURE_NETMASK == "" ]] ; then
            echo "Address and Mask must be specified to configure IPMI IP address"
            IPMI_CONFIGURE_FAIL=true
            disable_ipmi
        fi

        if [[ ${lan_info["ipsrc"]} != "Static Address" ]] ; then
            tool lan set $lan_chan ipsrc static
            configured=true
        fi

        if [[ ${lan_info["ipaddr"]} != $IPMI_CONFIGURE_ADDRESS ]] ; then
            tool lan set $lan_chan ipaddr $IPMI_CONFIGURE_ADDRESS
            configured=true
        fi

        if [[ ${lan_info["netmask"]} != $IPMI_CONFIGURE_NETMASK ]] ; then
            tool lan set $lan_chan netmask $IPMI_CONFIGURE_NETMASK
            configured=true
        fi

        if [[ ${lan_info["defgw ipaddr"]} != $IPMI_CONFIGURE_GATEWAY && $IPMI_CONFIGURE_GATEWAY != "" ]] ; then
            tool lan set $lan_chan defgw ipaddr $IPMI_CONFIGURE_GATEWAY
            configured=true
        fi
    fi
    # Configure the DNS and HOSTNAME
    if [[ $HP_SYSTEM == true ]] ; then
        if [[ -x /usr/sbin/hponcfg ]] ; then
          hponcfg -i <<EOF_STATIC
<RIBCL VERSION="2.1">
  <LOGIN USER_LOGIN="Administrator" PASSWORD="password">
    <RIB_INFO MODE="write">
      <MOD_NETWORK_SETTINGS>
{{ if .ParamExists "ipmi/configure/hostname" -}}
        <DNS_NAME VALUE = "{{.Param "ipmi/configure/hostname"}}"/>
{{ end -}}
{{ if .ParamExists "ipmi/configure/domain" -}}
        <DHCP_DOMAIN_NAME VALUE="N"/>
        <DOMAIN_NAME VALUE = "{{.Param "ipmi/configure/domain"}}"/>
{{ else if .ParamExists "dns-domain" -}}
        <DHCP_DOMAIN_NAME VALUE="N"/>
        <DOMAIN_NAME VALUE = "{{.Param "dns-domain"}}"/>
{{ end -}}
{{ if .ParamExists "ipmi/configure/dns-servers" -}}
        {{ $p := .Param "ipmi/configure/dns-servers" -}}
        {{ if $p -}}
        <DHCP_DNS_SERVER VALUE="N"/>
        <PRIM_DNS_SERVER value = "{{ index $p 0 }}"/>
        {{if lt 1 (len $p) }}
        <SEC_DNS_SERVER value = "{{ index $p 1 }}"/>
        {{ end -}}
        {{if lt 2 (len $p) }}
        <TER_DNS_SERVER value = "{{ index $p 2 }}"/>
        {{ end -}}
        {{ end -}}
{{ else if .ParamExists "dns-servers" -}}
        {{ $p := .Param "dns-servers" -}}
        {{ if $p -}}
        <DHCP_DNS_SERVER VALUE="N"/>
        <PRIM_DNS_SERVER value = "{{ index $p 0 }}"/>
        {{if lt 1 (len $p) }}
        <SEC_DNS_SERVER value = "{{ index $p 1 }}"/>
        {{ end -}}
        {{if lt 2 (len $p) }}
        <TER_DNS_SERVER value = "{{ index $p 2 }}"/>
        {{ end -}}
        {{ end -}}
{{ end -}}
{{ if .ParamExists "ipmi/configure/ntp-servers" -}}
        {{ $p := .Param "ipmi/configure/ntp-servers" -}}
        {{ if $p -}}
        <DHCP_SNTP_SETTINGS VALUE="N"/>
        {{if lt 0 (len $p) }}
        <SNTP_SERVER1 value = "{{ index $p 0 }}"/>
        {{ end -}}
        {{if lt 1 (len $p) }}
        <SNTP_SERVER2 value = "{{ index $p 1 }}"/>
        {{ end -}}
        {{ end -}}
{{ else if .ParamExists "ntp-servers" -}}
        {{ $p := .Param "ntp-servers" -}}
        {{ if $p -}}
        <DHCP_SNTP_SETTINGS VALUE="N"/>
        {{if lt 0 (len $p) }}
        <SNTP_SERVER1 value = "{{ index $p 0 }}"/>
        {{ end -}}
        {{if lt 1 (len $p) }}
        <SNTP_SERVER2 value = "{{ index $p 1 }}"/>
        {{ end -}}
        {{ end -}}
{{ end -}}
{{ if .ParamExists "ipmi/configure/timezone" -}}
        <TIMEZONE VALUE="{{.Param "ipmi/configure/timezone"}}"/>
{{ else -}}
  {{ if .ParamExists "timezone" -}}
        <TIMEZONE VALUE="{{.Param "timezone"}}"/>
  {{ end -}}
{{ end -}}
      </MOD_NETWORK_SETTINGS>
    </RIB_INFO>
    <USER_INFO MODE="write">
    </USER_INFO>
  </LOGIN>
</RIBCL>
EOF_STATIC
        else
            echo "HP system detected, but no hponcfg binary present."
            echo "Please rework your ipmi configure workload to make sure the"
            echo "hardware-tools-install stage is before the ipmi-configure stage."
            echo
            echo "This task cannot guarantee that remote access is enabled on this system without it."
        fi
    fi
    if [[ $DELL_SYSTEM == true ]] ; then
        racadm=/opt/dell/srvadmin/bin/idracadm7
        if which $racadm ; then
{{ if .ParamExists "ipmi/configure/domain" }}
            DNS_DOMAIN="{{.Param "ipmi/configure/domain"}}"
{{ else if .ParamExists "dns-domain" }}
            DNS_DOMAIN="{{.Param "dns-domain"}}"
{{ end }}
{{ if .ParamExists "ipmi/configure/hostname" }}
            DRACHOSTNAME="{{.Param "ipmi/configure/hostname"}}"
{{ end }}
{{ if .ParamExists "ipmi/configure/dns-servers" }}
        {{ $p := .Param "ipmi/configure/dns-servers" }}
        {{ if $p }}
            DNS_SERVER1="{{ index $p 0 }}"
        {{if lt 1 (len $p) }}
            DNS_SERVER2="{{ index $p 1 }}"
        {{ end }}
        {{ end }}
{{ else if .ParamExists "dns-servers" }}
        {{ $p := .Param "dns-servers" }}
        {{ if $p }}
            DNS_SERVER1="{{ index $p 0 }}"
        {{if lt 1 (len $p) }}
            DNS_SERVER2="{{ index $p 1 }}"
        {{ end }}
        {{ end }}
{{ end }}
{{ if .ParamExists "ipmi/configure/ntp-servers" }}
        {{ $p := .Param "ipmi/configure/ntp-servers" }}
        {{ if $p }}
        {{if lt 0 (len $p) }}
            NTP_ENABLED="Enabled"
            NTP_SERVER1="{{ index $p 0 }}"
        {{ end }}
        {{if lt 1 (len $p) }}
            NTP_ENABLED="Enabled"
            NTP_SERVER2="{{ index $p 1 }}"
        {{ end }}
        {{if lt 2 (len $p) }}
            NTP_ENABLED="Enabled"
            NTP_SERVER3="{{ index $p 2 }}"
        {{ end }}
        {{ end }}
{{ else if .ParamExists "ntp-servers" }}
        {{ $p := .Param "ntp-servers" }}
        {{ if $p }}
        {{if lt 0 (len $p) }}
            NTP_ENABLED="Enabled"
            NTP_SERVER1="{{ index $p 0 }}"
        {{ end }}
        {{if lt 1 (len $p) }}
            NTP_ENABLED="Enabled"
            NTP_SERVER2="{{ index $p 1 }}"
        {{ end }}
        {{if lt 2 (len $p) }}
            NTP_ENABLED="Enabled"
            NTP_SERVER3="{{ index $p 2 }}"
        {{ end }}
        {{ end }}
{{ end }}
{{ if .ParamExists "timezone" -}}
            TIME_ZONE="{{.Param "timezone"}}"
{{ end -}}
{{ if .ParamExists "ipmi/configure/timezone" -}}
            TIME_ZONE="{{.Param "ipmi/configure/timezone"}}"
{{ end -}}

            test -z $DRACHOSTNAME || $racadm set iDRAC.NIC.DNSRacName $DRACHOSTNAME
            test -z $DNS_DOMAIN || $racadm set iDRAC.NIC.DNSDomainName $DNS_DOMAIN
            test -z $DNS_SERVER1 || $racadm set iDRAC.IPv4.DNS1 $DNS_SERVER1
            test -z $DNS_SERVER2 || $racadm set iDRAC.IPv4.DNS2 $DNS_SERVER2
            test -z $TIME_ZONE || $racadm set iDRAC.time.timezone "$TIME_ZONE"
            test -z $NTP_SERVER1 || $racadm set idrac.NTPConfigGroup.ntp1 $NTP_SERVER1
            test -z $NTP_SERVER2 || $racadm set idrac.NTPConfigGroup.ntp2 $NTP_SERVER2
            test -z $NTP_SERVER3 || $racadm set idrac.NTPConfigGroup.ntp3 $NTP_SERVER3
            test -z $NTP_ENABLED || $racadm set idrac.NTPConfigGroup.ntpenable $NTP_ENABLED
        else
            echo "Dell system detected, but no $racadm binary present."
            echo "Please rework your ipmi configure workload to make sure the"
            echo "hardware-tools-install stage is before the ipmi-configure stage."
            echo
            echo "This task cannot guarantee that remote access is enabled on this system without it."
        fi
    fi
fi

if [[ $configured == true && $ipmi_hard_reset_after_config == true ]] ; then
    echo "BMC requires hard reset after config!!"
    echo "Sleeping 30"
    sleep 30
    echo "Resetting BMC"
    tool mc reset cold
    echo "Sleeping 30"
    sleep 30
fi

# Re-get the lan info
lan_info
IPMI_ADDRESS=${lan_info["ipaddr"]}
IPMI_NETMASK=${lan_info["netmask"]}
IPMI_GATEWAY=${lan_info["defgw ipaddr"]}
IPMI_MACADDR=${lan_info["macaddr"]}
IPMI_IPSRC=${lan_info["ipsrc"]}

# Record parameters.
drpcli machines set $RS_UUID param ipmi/enabled to true
if [[ $IPMI_ADDRESS != "" ]] ; then
    drpcli machines set $RS_UUID param ipmi/address to "$IPMI_ADDRESS"
    if [[ $IPMI_CONFIGURE_NETWORK == true ]] ; then
        # We weren't told the IP, but DHCP, bind it.
        if [[ $IPMI_CONFIGURE_RESERVE_IP == true && $IPMI_CONFIGURE_ADDRESS == "" ]] ; then
            MACADDR=${lan_info["macaddr"]}
            if [[ $(drpcli reservations show $IPMI_ADDRESS |jq -r '.Token') != $MACADDR ]]; then
                echo "Reserving (dhcp) $IPMI_ADDRESS for ${lan_info["macaddr"]}"
                data="{ \"Strategy\": \"MAC\", \"Addr\": \"$IPMI_ADDRESS\", \"Token\": \"$MACADDR\" }"
                drpcli reservations create "$data"
            fi
        fi
    fi
fi
if [[ $IPMI_NETMASK != "" ]] ; then
    drpcli machines set $RS_UUID param ipmi/netmask to "$IPMI_NETMASK"
fi
if [[ $IPMI_GATEWAY != "" ]] ; then
    drpcli machines set $RS_UUID param ipmi/gateway to "$IPMI_GATEWAY"
fi
if [[ $IPMI_MACADDR != "" ]] ; then
    drpcli machines set $RS_UUID param ipmi/macaddr to "$IPMI_MACADDR"
fi
if [[ $IPMI_IPSRC != "" ]] ; then
    drpcli machines set $RS_UUID param ipmi/ipsrc to "$IPMI_IPSRC"
fi

success

