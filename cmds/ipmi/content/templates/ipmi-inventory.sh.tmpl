#!/usr/bin/env bash
# Configure the IPMI subsystem

. helper

{{ if eq (.Param "rs-debug-enable") true -}}
set -x
{{end -}}

fail() {
    echo "Failed"
    exit 1
}

success() {
    echo "Success"
    exit 0
}

IPMI_FORCE_LAN_CHAN=0
IPMI_LAN_CHECK_START=1
IPMI_LAN_CHECK_END=11
{{if .ParamExists "ipmi/force-lan-chan"}}
IPMI_FORCE_LAN_CHAN={{.Param "ipmi/force-lan-chan"}}
IPMI_LAN_CHECK_START=$IPMI_FORCE_LAN_CHAN
IPMI_LAN_CHECK_END=$IPMI_FORCE_LAN_CHAN
{{end}}

declare -A quirk_data
declare -A mc_info
declare -A lan_info
declare -A lan6_info
lan_chan=0

quirklist=()
quirkid="UNKNOWN"

{{ template "ipmi-info-keys.sh.tmpl" . }}

#
# This routine will mark the parameters to skip IPMI on
# systems that don't have IPMI subsystems or fail.
#
disable_ipmi() {
    echo "IPMI Subsystem not available on this node."

    # Mark address as empty to make sure that actions aren't available.
    drpcli machines set $RS_UUID param ipmi/enabled to false
    drpcli machines remove $RS_UUID param ipmi/address || :
    [[ $IPMI_CONFIGURE_FAIL != true ]] && success || fail
}


load_ipmi() {
    echo "Loading IPMI modules"
    [[ -d /sys/module/ipmi_devintf ]] || modprobe ipmi_devintf &>/dev/null || :
    [[ -d /sys/module/ipmi_si ]] || modprobe ipmi_si &>/dev/null || :
    [[ -d /sys/module/ipmi_ssif ]] || modprobe ipmi_ssif &>/dev/null || :
    if ! [[ -d /sys/module/ipmi_si ||
            -d /sys/module/ipmi_devintf ||
            -d /sys/module/ipmi_ssif ]]; then
        echo "Failed to load ipmi kernel modules"
        disable_ipmi
        return
    fi
    [[ -e /dev/ipmi0 || -e /dev/ipmi/0 || -e /dev/ipmidev/0 ]] && return || :
    echo "No IPMI devices present"
    IPMI_CONFIGURE_FAIL=false
    disable_ipmi
}

trim() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

tool() {
    [[ $ipmi_nodelay ]] || sleep 5
    if [[  "$@" =~ password ]] ; then
        echo "ipmitool password setting command"
    else
        echo "ipmitool $@"
    fi >&2
    ipmitool "$@"
}

process_quirks() {
    OLD_IFS=$IFS
    IFS=""
    array=false
    index=0
    level=()
    tq=()
    score=0
    maxscore=0
    testvalue=""
    while read line
    do
            [[ $line =~ ^# ]] && continue
            front=${line%%:*}
            back=$(trim ${line#*:})

            oldarray=$array
            if [[ $front == $line ]] ; then
                front=${line%%-*}
                back=$(trim ${line#*-})
                array=true
                tq=()
            else
                array=false
            fi
            if [[ $oldarray != $array && $array == true ]] ; then
                index=0
            fi

            spaces="${front//[^ ]}"
            count=$((${#spaces} / 2))

            tf=$(trim $front)
            if [[ $back == "" ]] ; then
                    if [[ $count == 0 ]] ; then
                         if [[ $testvalue != "" ]] ; then
                                 if [[ ${mc_info[$testkey]} == $testvalue ]] ; then
                                     score=$(($score + $testscore))
                                 fi
                                 if [[ \"${mc_info[$testkey]}\" == $testvalue ]] ; then
                                     score=$(($score + $testscore))
                                 fi
                         fi
                         testvalue=""
                         if (( $maxscore < $score )) ; then
                             quirkid=${level[0]}
                             maxscore=$score
                             quirklist=$tq
                         fi
                         score=0
                    fi
                    if [[ $count == 3 ]] ; then
                         if [[ $testvalue != "" ]] ; then
                                 if [[ ${mc_info[$testkey]} == $testvalue ]] ; then
                                     score=$(($score + $testscore))
                                 fi
                                 if [[ \"${mc_info[$testkey]}\" == $testvalue ]] ; then
                                     score=$(($score + $testscore))
                                 fi
                         fi
                         testkey=$tf
                         testscore=1
                    fi
                    level[$count]=$tf
            else
                    if [[ $array == true ]] ; then
                        tq[$index]=$back
                    else
                        if [[ $count == 4 && $tf == "match" ]] ; then
                            testvalue=$back
                        fi
                        if [[ $count == 4 && $tf == "score" ]] ; then
                            testscore=$back
                        fi
                    fi
            fi

    done < "ipmi-quirks.yaml"
    if [[ $testvalue != "" ]] ; then
            if [[ ${mc_info[$testkey]} == $testvalue ]] ; then
                score=$(($score + $testscore))
            fi
            if [[ \"${mc_info[$testkey]}\" == $testvalue ]] ; then
                score=$(($score + $testscore))
            fi
    fi
    testvalue=""
    if (( $maxscore < $score )) ; then
        maxscore=$score
        quirkid=${level[0]}
        quirklist=$tq
    fi
    IFS=$OLD_IFS
}

mc_info() {
    echo "Gathering MC info"
    count=0
    while (($count < 5)) ; do
        while read line
        do
            tkey=$(trim ${line%%:*})
            key=${mc_info_keys["$tkey"]}
            value=$(trim ${line#*:})

            [[ $key && $value ]] || continue
            mc_info["$key"]="$value"
        done < <(tool mc info)

        [[ ${mc_info["version"]} ]] && break

        echo "attempt $count failed -  trying again..."
        count=$(($count + 1))
        sleep 1
    done

    if (($count == 5)) ; then
        echo "Failed to get base board controller info"
        disable_ipmi
    fi
}

lan6_info() {
   if ! grep -q lan6 < <(ipmitool help 2>&1); then
     echo "No ipv6 support in ipmitool, skipping ipv6 inventory"
     return 0
  fi
  local section k v
  OLD_IFS=$IFS
  IFS=""
  while read line; do
      case $line in
          'IPv6 Static Address'*) section='static address'; continue;;
          'IPv6 Dynamic Address'*) section='dynamic address'; continue;;
          'IPv6 Static Router'*) section='gw'; continue;;
          'IPv6 Dynamic Router'*) section='gw'; continue;;
          '    '*);;
          *) section=''; continue;;
      esac
      k="$(trim "${line%%:*}")"
      v="$(trim "${line#*:}")"
      case $section in
          '') continue;;
          'static address')
              [[ ${lan6_info['ipaddr']} ]] && continue
              [[ $k = Address && $v != ::/* ]] || continue
              lan6_info['ipaddr']="${v%/*}"
              lan6_info['netmask']="${v#*/}"
              lan6_info['ipsrc']='static'
              ;;
          'dynamic address')
              [[ ${lan6_info['ipaddr']} ]] && continue
              case $k in
                  'Source/Type')
                      [[ $v && $v != 'static' ]] || continue
                      lan6_info['ipsrc']="$v";;
                  'Address')
                      [[ $v != ::/* ]] || continue
                      lan6_info['ipaddr']="${v%/*}"
                      lan6_info['netmask']="${v#*/}";;
              esac;;
          'gw')
              [[ ${lan6_info['defgw ipaddr']} ]] && continue
              [[ $k = 'Address' ]] || continue
              [[ $v && $v != :: ]] || continue
              lan6_info['defgw ipaddr']="$v";;
      esac
  done < <(tool lan6 print $lan_chan)
  IFS=$OLD_IFS
}

lan_info() {
    echo "Gathering Lan Info"
    for ((i=$IPMI_LAN_CHECK_START;i<=$IPMI_LAN_CHECK_END;i++)); do
        lan_chan=$i
        while read line
        do
            tkey=$(trim ${line%%:*})
            [[ $tkey ]] || continue
            key=${lan_info_keys["$tkey"]}
            value=$(trim ${line#*:})

            [[ $key && $value ]] || continue
            lan_info["$key"]="$value"
        done < <(tool lan print $lan_chan)

        [[ $IPMI_FORCE_LAN_CHAN = $lan_chan || ${lan_info["ipsrc"]} ]] && break
    done
}


# Load the ipmi layer
load_ipmi

# Get MC info
mc_info

# Get Lan Info
lan_info
lan6_info

# Identify MC and get quirks
process_quirks

echo "System has been identified as: $quirkid"
echo "Using these quirks: ${quirklist[@]}"

# Set the quirks as vars
for q in "${quirklist[@]}"
do
        key=${q//-/_}
        export ${key}=true
done
declare -A p2li=(['ipaddr']='ipmi/address'
      ['netmask']='ipmi/netmask'
      ['ipsrc']='ipmi/ipsrc'
      ['defgw ipaddr']='ipmi/gateway')

if [[ ${lan_info['macaddr']} != "" ]] ; then
    drpcli machines set $RS_UUID param ipmi/macaddr to "${lan_info['macaddr']}"
fi

if [[ ${lan_info['ipaddr']} && ${lan_info['ipaddr']} != '0.0.0.0' || ${lan6_info['ipaddr']} ]]; then
   drpcli machines set $RS_UUID param ipmi/enabled to true
fi

if [[ ${lan_info['defgw ipaddr']} && {lan_info['defgw ipaddr']} != '0.0.0.0' ]]; then
    use_v4=true
fi

if [[ ${lan6_info['defgw ipaddr']} && {lan6_info['defgw ipaddr']} != '::' ]]; then
    use_v6=true
fi

if [[ $use_v4 && $use_v6 ]]; then
    case "{{.Param "ipmi/prefer-v6"}}" in
        true) unset use_v4;;
        false) unset use_v6;;
    esac
fi

{{ if .ParamExists "ipmi/force-protocol" }}
{{ if eq (.Param "ipmi/force-protocol") "v4" }}
unset use_v6
use_v4=true
{{ end }}
{{ if eq (.Param "ipmi/force-protocol") "v6" }}
unset use_v4
use_v6=true
{{ end }}
{{ end }}

for k in "${!p2li[@]}"; do
    if [[ ${lan_info["$k"]} ]]; then
        drpcli machines set "$RS_UUID" param "${p2li["$k"]}-v4" to "${lan_info["$k"]}"
        if [[ $use_v4 ]]; then
            drpcli machines set "$RS_UUID" param "${p2li["$k"]}" to "${lan_info["$k"]}"
        fi
    fi
    if [[ ${lan6_info["$k"]} ]]; then
        drpcli machines set "$RS_UUID" param "${p2li["$k"]}-v6" to "${lan6_info["$k"]}"
        if [[ $use_v6 ]]; then
            drpcli machines set "$RS_UUID" param "${p2li["$k"]}" to "${lan6_info["$k"]}"
        fi
    fi
done

success

