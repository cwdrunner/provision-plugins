#!/usr/bin/env sh
# Update an ESXi installed instance to a set patch level. Run in installed ESXi environment.

{{ if not (.Param "esxi/patches-enabled" ) -}}
echo "ESXi patching system turned off by Param 'esxi/patches-enabled'"
exit 0
{{ end -}}

xiterr() { [[ $1 =~ ^[0-9]+$ ]] && { XIT=$1; shift; } || XIT=1; printf "FATAL: $*\n"; exit $XIT; }
# setup.tmpl blows up in esxi
#\{\{ template "setup.tmpl" .\}\}

{{ if .ParamExists "esxi/patch-list-override" -}}
  # collect our defined list of patches
  {{ if .Param "esxi/patch-list" -}}
    {{ range $index, $list := .Param "esxi/patch-list" -}}
      P="$P {{ $list }}"
    {{ end -}}
  {{ end -}}

{{ else -}}{{/* exists esxi/patch-list-override */}}
  # no 'esxi/patch-list-override' was set - process 'esxi/patch-list'
  # process the vmware/esxi-version-vendor-map for patch list
  {{ $vend := .Param "esxi/selected-vendor" }}
  {{ range $index, $vendmap := .Param "vmware/esxi-version-vendor-map" }}
    {{ if eq $vend $index }}
      {{ range $id, $patch := $vendmap.patches }}
        P="$P {{ $patch }}"
      {{ end -}}
    {{ end -}}
  {{ end -}}{{/* range vmware/esxi-version-vendor-map */}}
{{ end -}}{{/* exists esxi/patch-list-override */}}

# patch up our patch list
PATCH_LIST="$(echo -e "${P}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
[[ -z "$PATCH_LIST" ]] && { echo "No 'esxi/patch-list' generated, skipping patches"; exit 0; }

# param expansion must happen outside of 'range' unless use other constructs inside
MIRROR="{{ .Param "esxi/patch-mirror" }}"
PATCH_DS="{{ .Param "esxi/install-datastore" }}/rackn/patches"
[[ ! -d "$PATCH_DS" ]] && mkdir -p "$PATCH_DS"

# iterate over our PATCH_LIST and get them
for PATCH in $PATCH_LIST
do
  {{ range $index, $build := .Param "esxi/patch-map" -}}

  BUILD_NUMBER="{{$index}}"
  [[ "$PATCH" != "$BUILD_NUMBER" ]] && continue

  REL_NAME="{{$build.release_name}}"
  FILE_NAME="{{$build.filename}}"
  REBOOT_REQUIRED="{{$build.reboot_required}}"
  LOCATION="{{$build.location}}"
  CHECKSUM_TYPE="{{$build.checksum.type}}"
  CHECKSUM_VALUE="{{$build.checksum.value}}"

  [[ $RS_DEBUG_ENABLE ]] FMT="%16s: "
  [[ $RS_DEBUG_ENABLE ]] printf "$FMT %s\n" "BUILD_NUMBER" "$BUILD_NUMBER"
  [[ $RS_DEBUG_ENABLE ]] printf "$FMT %s\n" "REL_NAME" "$REL_NAME"
  [[ $RS_DEBUG_ENABLE ]] printf "$FMT %s\n" "FILE_NAME" "$FILE_NAME"
  [[ $RS_DEBUG_ENABLE ]] printf "$FMT %s\n" "REBOOT_REQUIRED" "$REBOOT_REQUIRED"
  [[ $RS_DEBUG_ENABLE ]] printf "$FMT %s\n" "LOCATION" "$LOCATION"
  [[ $RS_DEBUG_ENABLE ]] printf "$FMT %s\n" "CHECKSUM_TYPE" "$CHECKSUM_TYPE"
  [[ $RS_DEBUG_ENABLE ]] printf "$FMT %s\n" "CHECKSUM_VALUE" "$CHECKSUM_VALUE"

  [[ "$LOCATION" =~ ^\<no\ value\>$ ]] && LOCATION="${MIRROR}"
  [[ -z "$LOCATION" ]] && xiterr "No download location specified (see 'esxi/patch-mirror' param)"

  SUM=$(mktemp /tmp/checksum.XXXXXXX)
  wget -P "$PATCH_DS" $LOCATION/$FILE_NAME
  echo "$CHECKSUM_VALUE  $PATCH_DS/$FILE_NAME" > $SUM
  if $(eval ${CHECKSUM_TYPE}sum -cs $SUM)
  then
    echo "$CHECKSUM_TYPE checksum value ('$CHECKSUM_VALUE') matches for file $PATCH_DS/$FILE_NAME"
  else
    xiterr 1 "BAD $CHECKSUM_TYPE checksum value ('$CHECKSUM_VALUE') for file $PATCH_DS/$FILE_NAME.  Corrupted Download?"
  fi
  rm -f $SUM

  echo "Saved patch file:"
  ls -lh "$PATCH_DS/$FILE_NAME"

  ########################## TODO
  #
  #  check if the current version matches the patch set
  #  if not - Need to set maintenance mode
  #  apply patch set
  #  insure DRPY starts up on boot
  #  if reboot set, reboot
  #  on boot up validate current version matches patch set
  #  clear maintenance mode
  #
  ########################## TODO

  {{ end -}}
done # end for PATCH in


exit 0


#  NOTES
#   maintenance mode
#   process the esxi/patches-to-apply array
#   for each patch lookup values in esxi/patch-map
#   build up the task list
#   insert "start task" (put in maint. mode)
#   need to handle the "reboot-required" case to the list
#   probably need a "reboot" task in between
#   probably need a "finish" task which disables maint. mode

wget {{ .ProvisionerURL }}/files/vmware/patches/ESXi670-201906002.zip -O /vmfs/volumes/datastore1/ESXi670-201906002.zip
#wget $MIRROR/ESXi670-201906002.zip -O $PATCH_DS/ESXi670-201906002.zip
#wget http://192.168.124.1:8091/files/vmware/patches/ESXi670-201906002.zip

# put ESXi in maintenance mode
# NOTE - does not work in Weasel - not needed
vim-cmd hostsvc/maintenance_mode_enter

# install the patches/updates
# likely need to find the Vendor specific version of these to stage/use
# if in Weasel - do:
#localcli software acceptance set --level=CommunitySupported
esxcli software vib update -d /vmfs/volumes/datastore1/rackn/patches/ESXi670-201906002.zip

# next steps - verify the output:
#
#      The update completed successfully, but the system needs to be rebooted for changes to be effective.
#
# then:
reboot

####### next boot steps - requires coordination with onetime script - or
####### preferably workflow

# return the system back to operational state
# maybe have the welcome/dcui splash screen rerun on next boot
# **RE**render the welcome script to VMFS rackn location - then twiddle the /etc/rc.local.d/local.sh to execute it

vim-cmd hostsvc/maintenance_mode_exit


